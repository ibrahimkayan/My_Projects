# Magical Map 

This project simulates a **dynamic pathfinding system** using **Dijkstra's algorithm** on a magical map grid. The world is gradually revealed, obstacles appear during traversal, and strategic decisions must be made using wizard offers to unlock blocked paths.

## ðŸ§­ Overview

- The map is a 2D grid with different node types, each with passability and directional cost properties.
- The agent begins at a known start position and must reach a sequence of **mission objectives** (targets).
- As the agent moves, new obstacles may be revealed, triggering **real-time path recalculations**.
- In some cases, a **wizard** offers magical options to remove obstacles by converting node types.
- The system uses **Dijkstraâ€™s shortest path algorithm** to compute the optimal path based on edge costs and visibility.


## ðŸ” Key Features

- âœ… Dynamic grid updates as the agent discovers new obstacles
- âœ… Recalculates shortest path on-the-fly using Dijkstra
- âœ… Wizard interaction logic with decision-making for optimal cost
- âœ… Modular code: Dijkstra class, node system, and objective tracking
- âœ… Cost-based neighbor traversal using directional distances
## ðŸš€ How to Run
To successfully compile and run the program, ensure all required files are in the same directory:

Required Files
Main.java â€” main program logic

input.txt â€” input grid and mission objectives

output.txt â€” output log generated by the program

expected_output.txt â€” optional: for comparing results (if provided)

Run Instructions
bash
Copy
Edit
javac Main.java
java Main
The program reads from input.txt in the same folder.

All output (movement logs, wizard choices, etc.) will be written to output.txt.

âš ï¸ Make sure Main.java, input.txt, output.txt, and (if used) expected_output.txt are located in the same directory, otherwise the program may not function as expected.


## ðŸ§  Core Logic â€” Dijkstra's Algorithm

```java
// Initialize distances and previous node tracker
double[][] distances = new double[rows][cols];
Node[][] previous = new Node[rows][cols];

// MinHeap with custom comparator based on distances
MinHeap myMinHeap = new MinHeap(Comparator.comparingDouble(n -> distances[n.x][n.y]));

// Start from source node
distances[startX][startY] = 0;
myMinHeap.add(grid[startX][startY]);

// Main loop
while (!myMinHeap.isEmpty()) {
    Node current = myMinHeap.RemoveMin();
    if (current is target) break;

    for (neighbor in neighbors) {
        if (neighbor is passable) {
            double newDist = distances[current] + getDistance(current, neighbor);
            if (newDist < distances[neighbor]) {
                distances[neighbor] = newDist;
                previous[neighbor] = current;
                myMinHeap.add(neighbor);
            }
        }
    }
} 

